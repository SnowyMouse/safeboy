use alloc::borrow::Cow;
use alloc::vec::Vec;
use crate::RunningGameboy;

/// Callbacks you can implement when using the emulator.
#[allow(unused_variables)]
pub trait GameboyCallbacks {
    /// A byte `original_data` is about to be read.
    ///
    /// Return a different byte to override it.
    ///
    /// # Remarks
    ///
    /// This callback is disabled by default. Use the `enable_memory_callbacks` function to enable
    /// it.
    fn read_memory(&mut self, instance: &mut RunningGameboy, address: u16, original_data: u8) -> u8 {
        original_data
    }

    /// A byte is about to be written.
    ///
    /// Return `true` to allow it and `false` to discard the write.
    ///
    /// # Remarks
    ///
    /// This callback is disabled by default. Use the `enable_memory_callbacks` function to enable
    /// it.
    fn write_memory(&mut self, instance: &mut RunningGameboy, address: u16, data: u8) -> bool {
        true
    }

    /// An instruction is about to be executed.
    ///
    /// # Remarks
    ///
    /// This callback is disabled by default. Use the `enable_memory_callbacks` function to enable
    /// it.
    fn executing_instruction(&mut self, instance: &mut RunningGameboy, address: u16, opcode: u8) {}

    /// Vertical blank was reached.
    ///
    /// Generally this means a full frame was rendered, thus it is safe to read the pixel buffer.
    fn vblank(&mut self, instance: &mut RunningGameboy, vblank_type: VBlankType) {}

    /// A bit is being sent by the emulator to another system.
    ///
    /// `bit` corresponds to the bit being transferred.
    fn serial_transfer_bit_start(&mut self, instance: &mut RunningGameboy, bit: bool) {}

    /// A bit is being requested by the emulator for serial transfer.
    ///
    /// This function should return the bit being requested (with `true` as 1 and `false` as 0).
    fn serial_transfer_bit_end(&mut self, instance: &mut RunningGameboy) -> bool { true }

    /// Hint to update controller input.
    ///
    /// You can use this callback to poll controller input just before it is needed to minimize
    /// input latency and then set with the [`set_input_button_mask`] or [`set_input_button_state`]
    /// methods.
    ///
    /// [`set_input_button_mask`]: crate::RunnableInstanceFunctions::set_input_button_mask
    /// [`set_input_button_state`]: crate::RunnableInstanceFunctions::set_input_button_state
    fn update_input_hint(&mut self, instance: &mut RunningGameboy) {}

    /// Hint to load a boot ROM.
    ///
    /// Use this to automatically select a boot ROM if your emulator frontend supports multiple
    /// systems.
    ///
    /// You can then call [`load_boot_rom`](crate::RunnableInstanceFunctions::load_boot_rom) to load
    /// the boot ROM.
    fn load_boot_rom_hint(&mut self, instance: &mut RunningGameboy, boot_rom_type: BootRomType) {}

    /// The infrared state has changed.
    fn infrared(&mut self, instance: &mut RunningGameboy, on: bool) {}

    /// The rumble state has changed.
    fn rumble(&mut self, instance: &mut RunningGameboy, amplitude: f64) {}

    /// A page has been printed.
    fn printer_page(&mut self, instance: &mut RunningGameboy, page: PrinterPage) {}

    /// A message is being logged.
    fn console_log(&mut self, instance: &mut RunningGameboy, string: &str, attributes: LogAttributes) {}

    /// Text input is being requested.
    fn console_input(&mut self, instance: &mut RunningGameboy) -> Option<Cow<'static, str>> { None }

    /// An audio sample has been generated by the APU.
    fn apu_sample(&mut self, instance: &mut RunningGameboy, left: i16, right: i16) {}
}

/// Suggestion on how to draw the log message.
#[derive(Copy, Clone, PartialEq, Debug)]
#[allow(missing_docs)]
pub struct LogAttributes {
    pub bold: bool,
    pub dashed_underline: bool,
    pub underline: bool
}

/// Type of boot rom to load.
#[derive(Copy, Clone, PartialEq, Debug)]
#[allow(missing_docs)]
pub enum BootRomType {
    Dmg0,
    Dmg,
    Mgb,
    Sgb,
    Sgb2,
    Cgb0,
    Cgb,
    CgbE,
    Agb0,
    Agb
}

/// Type of vblank.
#[derive(Copy, Clone, PartialEq, Debug)]
#[allow(missing_docs)]
pub enum VBlankType {
    Normal,
    Artificial,
    SkippedFrame,
    Repeat,
    LCDOff
}

/// Printer page being read.
#[derive(Clone)]
pub struct PrinterPage {
    /// Data in pixels (encoded using the current RGB encoder)
    pub data: Vec<u32>,

    /// Width in pixels
    pub width: u8,

    /// Content height in pixels
    pub content_height: u8,

    /// Top margin in pixels
    pub top_margin: u8,

    /// Bottom margin in pixels
    pub bottom_margin: u8,

    /// Exposure to use
    pub exposure: u8
}
impl PrinterPage {
    /// Get the dimensions in `(width, height)`
    pub const fn get_dimensions(&self) -> (u16, u16) {
        (self.width as u16, (self.content_height as u16) + (self.top_margin as u16) + (self.bottom_margin as u16))
    }
}